# Comparison of tRPC, gRPC, GraphQL, and REST

| **Aspect**             | **tRPC**                                                                 | **gRPC**                                                          | **GraphQL**                                                      | **REST**                                                      |
|-------------------------|--------------------------------------------------------------------------|-------------------------------------------------------------------|------------------------------------------------------------------|--------------------------------------------------------------|
| **Definition**          | TypeScript-based remote procedure call (RPC) framework.                 | Protocol for fast, efficient, and typed communication.            | Query language for APIs that allows clients to request specific data. | Architectural style for building APIs using standard HTTP methods. |
| **Communication Style** | Function calls with automatic TypeScript support.                      | RPC with Protocol Buffers (protobuf).                             | Client-driven queries over HTTP.                                 | Resource-based operations over HTTP.                        |
| **Transport**           | HTTP (mostly)                                                          | HTTP/2 or HTTP/3.                                                  | HTTP (or WebSockets for subscriptions).                         | HTTP.                                                        |
| **Data Format**         | JSON (Type-safe via TypeScript).                                        | Compact binary format (Protocol Buffers).                        | JSON.                                                           | JSON, XML, or any format (commonly JSON).                   |
| **Type Safety**         | End-to-end type safety through TypeScript.                             | Strongly typed via Protocol Buffers.                              | No built-in type safety, but can use schemas (e.g., TypeScript, GraphQL schema). | No built-in type safety, relies on documentation and conventions. |
| **Flexibility**         | Limited; server-side functions must match client-side usage.            | Highly efficient but less flexible for dynamic queries.           | Extremely flexible; clients can specify exact data requirements. | Limited; predefined endpoints dictate data responses.        |
| **Performance**         | Good for most web use cases; lightweight compared to GraphQL.           | High performance due to binary format and streaming support.      | Can be slower due to nested queries and over-fetching/under-fetching. | Medium performance, depends on payload size and network latency. |
| **State Management**    | Built-in through TypeScript integration.                               | Requires external state management.                               | Requires integration with state management tools.               | Requires external state management.                         |
| **Best Use Cases**      | Full-stack TypeScript apps.                                           | - Real-time services (e.g., chat, gaming).                       | - Frontends with diverse and dynamic data needs.                | - Simple, CRUD-style APIs.                                  |
|                         | Small to medium apps with developer efficiency as priority.          | - Microservices communication.                                   | - API gateways aggregating multiple sources.                    | - RESTful APIs with well-defined resources.                 |
| **Limitations**         | Limited cross-language support (TypeScript-specific).                  | Steeper learning curve, tooling setup required.                   | Requires more bandwidth and client-side tooling for caching.    | Over-fetching or under-fetching data, rigid structure.      |
| **When to Use**         | Youâ€™re building a TypeScript-first application.                      | - Need performance and low latency.                              | - Need flexibility for dynamic client queries.                  | - Simple APIs with predictable resource structures.         |
|                         | Want type-safe, developer-friendly API calls.                       | - Require real-time streaming (e.g., video, sensors).            | - Data is retrieved from multiple sources or aggregated APIs.   | - Traditional APIs or simple CRUD operations.               |
